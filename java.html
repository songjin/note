<!DOCTYPE html>
<html>
<head>
	<meta charset="UTF-8">
	<link rel="stylesheet" type="text/css" href=./style.css>
</head>

<body>
	<h1>Java 笔记</h1>

<h3>Java特点</h3>

<ul>
<li>cross-platform （JVM的优秀）</li>
<li>OOP</li>
<li>GC</li>
<li>Speed（相对于Python　Ruby）</li>
<li>学习资源</li>
<li>强类型，静态</li>
<li>Android</li>
</ul>

<h3>main</h3>

<pre><code>public static void main(String[] args)
</code></pre>

<h3>Type</h3>

<ul>
<li>boolean 与　int不相容</li>
<li>primitive：

<ul>
<li>boolean</li>
<li>char (16)</li>
<li>byte (8)</li>
<li>short (16)</li>
<li>int (32)</li>
<li>long (64)</li>
<li>float (32)</li>
<li>double (64)</li>
</ul></li>
<li>初始值
-　int, char : 0

<ul>
<li>boolean :false</li>
<li>引用: null</li>
</ul></li>
<li>All operate of the Object is refrence</li>
<li>==

<ul>
<li>比较基类</li>
<li>比较引用是否链接到同一个对象</li>
</ul></li>
</ul>

<h3>Control　Flow</h3>

<ul>
<li>for(int type: typeSet) {}</li>
</ul>

<h3>OO</h3>

<ul>
<li>ArrayList<class> myList = new ArrayList<class> ()</li>
<li>import</li>
<li>extends</li>
<li><p>private  delfault protected public (public会被继承，pravite不会)</p></li>
<li><p>the refrence can be the father class  e.g. <code>Animal[1] = new Dog()</code>, <code>Animal[1].eat</code> calls <code>Dog.eat()</code></p></li>
<li><p>参数和返回类型也可以用负父类</p></li>
<li><p>重载方法　参数和return类型都要相同，而且不能降低权限</p></li>
<li><p>抽象类
<code>abstract xxx classname</code>  不能被new</p></li>
<li><p>抽象方法　<code>public abstract xxx</code> 没有实体</p></li>
<li><p>Object　Class的方法：　equal　,getClass, toString, hashCode</p></li>
<li><p>根据引用来判断methon调用而不是Objective类型</p></li>
<li><p>inferface　接口类似于１００％的抽象类</p></li>
<li><p>public inferface Pet{}</p></li>
<li><p>public class Dog extends Cannie implements Pet {}</p></li>
<li><p>heap 里面只有对象，局部变量，方法调用，原始类型，引用都在stack里面，实例变量在对象所属的堆空间上</p></li>
<li><p>构造函数　覆盖</p></li>
<li><p>构造很熟　super　编译器会给无参数的构造函数加上super，有参数要自己super(arg)</p></li>
<li><p>this对自身的引用，与super不能同时用</p></li>
<li><p>静态方法（类方法））</p></li>
<li><p>static</p></li>
<li><p>静态变量</p></li>
<li><p>final</p></li>
</ul>

</body>
</html>

